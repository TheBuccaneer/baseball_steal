"""
MLB Season Downloader - Alle Play-by-Play Daten einer Saison
Nutzung: python script.py --year 2024 --output data/mlb_2024.parquet
"""

import statsapi
import pandas as pd
import argparse
from pathlib import Path
from datetime import datetime
import time

def get_season_games(year):
    """Hole alle Regular Season Spiele eines Jahres"""
    print(f"\nüîç Suche alle Spiele der {year} Regular Season...")
    
    # MLB Regular Season: ca. M√§rz bis September
    start_date = f"{year}-03-01"
    end_date = f"{year}-10-31"
    
    games = statsapi.schedule(start_date=start_date, end_date=end_date)
    
    # Nur Regular Season (game_type = 'R'), keine Playoffs
    regular_season = [g for g in games if g.get('game_type') == 'R' and g['status'] == 'Final']
    
    print(f"‚úÖ {len(regular_season)} Spiele gefunden")
    return regular_season

def extract_play_data(game_id, game_info):
    """Extrahiere alle Play-Daten aus einem Spiel"""
    try:
        playbyplay = statsapi.get('game_playByPlay', {'gamePk': game_id})
        
        plays_data = []
        
        for play in playbyplay.get('allPlays', []):
            # Basis-Info
            about = play.get('about', {})
            result = play.get('result', {})
            matchup = play.get('matchup', {})
            count = play.get('count', {})
            
            # Runner-Bewegungen
            runners = play.get('runners', [])
            runner_movements = []
            for runner in runners:
                movement = runner.get('movement', {})
                details = runner.get('details', {})
                runner_info = details.get('runner', {})
                
                if movement.get('start') and movement.get('end'):
                    runner_movements.append({
                        'runner_id': runner_info.get('id'),
                        'runner_name': runner_info.get('fullName'),
                        'start_base': movement.get('start'),
                        'end_base': movement.get('end'),
                        'is_out': movement.get('isOut', False),
                        'out_number': movement.get('outNumber')
                    })
            
            # Wenn keine Runner-Bewegung, dann trotzdem den Play speichern
            if not runner_movements:
                runner_movements = [{}]
            
            # F√ºr jeden Runner eine Zeile
            for runner_mov in runner_movements:
                play_row = {
                    # Game Info
                    'game_id': game_id,
                    'game_date': game_info['game_date'],
                    'away_team': game_info['away_name'],
                    'home_team': game_info['home_name'],
                    'away_score': game_info.get('away_score'),
                    'home_score': game_info.get('home_score'),
                    
                    # Play Context
                    'inning': about.get('inning'),
                    'half_inning': about.get('halfInning'),
                    'at_bat_index': about.get('atBatIndex'),
                    
                    # Count
                    'balls': count.get('balls'),
                    'strikes': count.get('strikes'),
                    'outs': count.get('outs'),
                    
                    # Matchup
                    'batter_id': matchup.get('batter', {}).get('id'),
                    'batter_name': matchup.get('batter', {}).get('fullName'),
                    'batter_side': matchup.get('batSide', {}).get('code'),
                    'pitcher_id': matchup.get('pitcher', {}).get('id'),
                    'pitcher_name': matchup.get('pitcher', {}).get('fullName'),
                    'pitcher_hand': matchup.get('pitchHand', {}).get('code'),
                    
                    # Result
                    'event': result.get('event'),
                    'event_type': result.get('eventType'),
                    'description': result.get('description'),
                    'rbi': result.get('rbi', 0),
                    'away_score_after': result.get('awayScore'),
                    'home_score_after': result.get('homeScore'),
                    
                    # Runner Movement (falls vorhanden)
                    'runner_id': runner_mov.get('runner_id'),
                    'runner_name': runner_mov.get('runner_name'),
                    'start_base': runner_mov.get('start_base'),
                    'end_base': runner_mov.get('end_base'),
                    'is_out': runner_mov.get('is_out'),
                    'out_number': runner_mov.get('out_number'),
                }
                
                plays_data.append(play_row)
        
        return plays_data
    
    except Exception as e:
        print(f"  ‚ö†Ô∏è  Fehler bei Game {game_id}: {e}")
        return []

def download_season(year, output_path):
    """Hauptfunktion: Lade komplette Saison"""
    print(f"\n{'='*80}")
    print(f"MLB Season Downloader - {year}")
    print(f"{'='*80}")
    
    # 1. Hole alle Spiele
    games = get_season_games(year)
    
    if not games:
        print("‚ùå Keine Spiele gefunden!")
        return
    
    # 2. Iteriere durch alle Spiele
    all_plays = []
    total_games = len(games)
    
    print(f"\nüì• Lade Play-by-Play Daten...")
    print(f"{'='*80}\n")
    
    for i, game in enumerate(games, 1):
        game_id = game['game_id']
        
        # Progress
        if i % 10 == 0 or i == 1:
            print(f"  [{i}/{total_games}] Game {game_id}: {game['away_name']} @ {game['home_name']}")
        
        # Extrahiere Daten
        plays = extract_play_data(game_id, game)
        all_plays.extend(plays)
        
        # Rate limiting - nicht zu schnell
        if i % 50 == 0:
            time.sleep(1)
    
    # 3. Speichere als DataFrame
    print(f"\nüíæ Speichere Daten...")
    df = pd.DataFrame(all_plays)
    
    # Erstelle Output-Ordner falls n√∂tig
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Speichere als Parquet (kompakter als CSV)
    df.to_parquet(output_path, index=False)
    
    # Statistik
    print(f"\n{'='*80}")
    print(f"‚úÖ FERTIG!")
    print(f"{'='*80}")
    print(f"Gespeichert: {output_path}")
    print(f"Spiele: {total_games:,}")
    print(f"Plays: {len(df):,}")
    print(f"Dateigr√∂√üe: {output_path.stat().st_size / 1024 / 1024:.1f} MB")
    print(f"\nSpalten ({len(df.columns)}):")
    for col in df.columns:
        print(f"  ‚Ä¢ {col}")
    
    # Zeige Beispiel-Daten
    print(f"\nüìã Erste 3 Zeilen:")
    print(df.head(3).to_string())

def main():
    parser = argparse.ArgumentParser(description='Download MLB Season Play-by-Play Data')
    parser.add_argument('--year', type=int, required=True, help='Saison Jahr (z.B. 2024)')
    parser.add_argument('--output', type=str, required=True, help='Output Pfad (z.B. data/mlb_2024.parquet)')
    
    args = parser.parse_args()
    
    # Validierung
    current_year = datetime.now().year
    if args.year < 2008 or args.year > current_year:
        print(f"‚ùå Jahr muss zwischen 2008 und {current_year} sein")
        return
    
    # Start Download
    start_time = time.time()
    download_season(args.year, args.output)
    
    elapsed = time.time() - start_time
    print(f"\n‚è±Ô∏è  Gesamtdauer: {elapsed/60:.1f} Minuten")

if __name__ == "__main__":
    main()